#include "scbd.h"

static int MAX_PAGES = INT_MAX;
static int MAX_BOOKS_IN_CURR_PAGE = INT_MAX;

int render_and_exec(char args[][LOGMSG_SIZE * 2]) {
   struct pages pages;
   pages.bitset = 0u;
   int selected_book, curr_page = 0, status;
   char* log_msg = NULL;
   int download_book_page_status = 0;
   greeting_message(); /* welcome to scbd etc etc */
   while (download_book_page_status == 0) {
     /*
      * Passar para a função abaixo:
      * numero maximo de paginas (config.h)
      * matriz de paginas de busca (a qual será alocada dinamicamente na função)
      * -> tudo isso para melhorar a ux (se o usuário desejar
      *                                  navegar de uma pagina pra outra
      * repetidamente)
      * */
     status = download_search_page(
         args[SEARCH_PATTERN], &log_msg, &pages.lib[curr_page].books,
         &pages.lib[curr_page].size, curr_page, &pages.bitset);
     if (status == SUCCESS) {
        MAX_BOOKS_IN_CURR_PAGE = pages.lib[curr_page].size;
       if ((selected_book = user_input(
                "Select a book [1 - n] or [p|P]age [1 - n] ([q|Q|0] to exit)",
                "Input a number to pick a book or p[NUM] to jump to NUM page",
                check_input_search_page)) == SUCCESS) {
          pages_book_t_free(&pages);
         return EXIT_SUCCESS;
       } else if(selected_book < FAILURE) {
          curr_page = -(selected_book + 1) - 1;
          continue;
       }

       download_mirror_page(&pages.lib[curr_page].books[selected_book],
                            &log_msg);

       /* first download the book page in gen lib then download the document it
        * self */
       if ((download_book_page_status = download_book_page(
                &pages.lib[curr_page].books[selected_book], &log_msg)) == SUCCESS) {
         log_msg = download_book(&pages.lib[curr_page].books[selected_book],
                                 &log_msg);
          download_book_page_status = 1;
         /* has been checked inside the function */
       } else if(download_book_page_status != FAILURE) {
          download_book_page_status = FAILURE;
          break;
       }
     } else {
       user_input_arg("Do you want to retry? ",
                      "Input a search string or [n]o to quit.",
                      args[SEARCH_PATTERN]);
       pages_book_t_free(&pages);
     }
   }
   if(download_book_page_status != FAILURE) {
      success_message(log_msg);
   }
   pages_book_t_free(&pages);
   return EXIT_SUCCESS;
}

void greeting_message(void) {
   /* font generated by figlet */
   puts("          _         _ \n"
        " ___  ___| |__   __| |\n"
        "/ __|/ __| '_ \\ / _` |\n"
        "\\__ | (__| |_) | (_| |\n"
        "|___/\\___|_.__/ \\__,_|\n"
        "\nWelcome to Simple C Book Downloader!"
        "We're looking for your book, may take a while.\n");
}

void help_message(void) {
   puts("Simple C Book Downloader\n"
        "Search for books/articles in Library Genesis\n"
        "\nRequired arguments");
   printf("\t%-16s Set the string search (usually author/book name)\n", "-s");
   puts("optional arguments:");
   printf("\t%-16s Show this help message\n", "-h");
   printf("\t%-16s Set another reference folder (where .bib will be downloaded)\n", "-b");
   printf("\t%-16s Set another book folder\n\n", "-d");
   usage();
}

void success_message(char *msg) {
  printf("%s\nYour book is in %s dir.\n", msg + 1, save_dir);
  if (*save_ref_dir) {
    printf("The book .bib reference file is in %s dir.\n", save_ref_dir);
  }
  puts("Have a nice day!\n");
  free(msg);
}

void check_log_msg(char* msg) {
   if(*msg) {
      fprintf(stderr, "%s\n", msg);
      free(msg);
      exit_and_report();
   }
   free(msg);
}

int download_search_page(char *pattern, char **log_msg,
                         struct book_t **books, int *books_len,
                         const int curr_page, uint64_t *cached_pages) {
  int status;
  if(is_cached(curr_page, *cached_pages)) {
    status = SUCCESS;
  } else {
    FILE *rcvd_file = NULL;
    enum { EXTRA_ARGS_LEN = 32 };
    char extra_args[EXTRA_ARGS_LEN] = { '\0' };
    sprintf(extra_args, "&res=%d&page=%d", MAX_BOOKS_PER_PAGE, curr_page + 1);
    char *full_path = (char *)ecalloc(
        strlen(gen_lib_search_path) + strlen(pattern) + EXTRA_ARGS_LEN + 1, sizeof(char));

    for(int i=0; pattern[i]; i += 1) {
       if(isspace(pattern[i])) {
          pattern[i] = '+';
       }
    }

    strcpy(full_path, gen_lib_search_path);
    strcat(full_path, pattern);
    strcat(full_path , extra_args);
    /* Create a tmpfile for the html page */
    *log_msg = page_downloader(gen_lib, full_path, TMP_FILE, &rcvd_file);
    free(full_path);
    check_log_msg(*log_msg);

    *log_msg =
        search_page(rcvd_file, books, books_len, &status, &MAX_PAGES);
    if(curr_page == 0) {
      MAX_PAGES = MIN(MAX_PAGES, (int) sizeof(uint64_t)*8);
      *books_len = MIN(*books_len, MAX_BOOKS_PER_PAGE);
    }
    check_log_msg(*log_msg);
    *cached_pages |= (1ULL << curr_page);
  }

  print_table_of_books(*books, *books_len, curr_page, status);
  print_cached_pages(*cached_pages);
  return status;
}

uint64_t is_cached(const int curr_page, const uint64_t cached_pages) {
   return cached_pages & (1ULL << curr_page);
}

void print_cached_pages(const uint64_t bitset) {
  printf("Cached pages (instant loading): ");
  FOR_BITSET(bitset, cursor) {
     if(cursor) {
        printf(", ");
     }
     printf("%lu", cursor + 1);
  }
  putchar('\n');
}

void download_mirror_page(struct book_t *selected_book, char **log_msg) {
   FILE* rcvd_file = NULL;

   *log_msg = page_downloader(gen_lib, selected_book->url, TMP_FILE, &rcvd_file);
   check_log_msg(*log_msg);

   *log_msg = mirror_page(rcvd_file, selected_book);
   check_log_msg(*log_msg);
}

bool download_book_page(struct book_t *selected_book, char **log_msg) {
   FILE* rcvd_file = NULL;
   char *hostname, *path;
   split_url(selected_book->url, &hostname, &path);
   *log_msg = page_downloader(hostname, path, TMP_FILE, &rcvd_file);
   free(hostname);
   free(path);
   check_log_msg(*log_msg);

   *log_msg = book_page(rcvd_file, selected_book);
   check_log_msg(*log_msg);

   print_more_info(selected_book);
   return user_input("Continue?", "[y]es or [n]o", check_input_book);
}

char *download_book(struct book_t *selected_book, char** log_msg) {
   FILE* rcvd_file = NULL;
   long book_filename_len;
   selected_book->path = get_dir(save_dir, &book_filename_len);
   char *hostname, *path;
   split_url(selected_book->download_url, &hostname, &path);
   *log_msg = page_downloader(hostname, path, !TMP_FILE, &rcvd_file,
                              &selected_book->path, book_filename_len);
   free(hostname);
   free(path);
   fclose(rcvd_file);
   generate_ref(selected_book, book_filename_len);
   return *log_msg;
}

void generate_ref(const struct book_t *selected_book, const long book_fn_len) {
  if (*save_ref_dir) {
    long ref_dir_len;
    char *ref_dir = get_dir(save_ref_dir, &ref_dir_len);
    const long book_path_len = strlen(selected_book->path);
    char *ref_filename = ecalloc(
        (book_path_len - book_fn_len + 4) + ref_dir_len, sizeof(char));
    strcpy(ref_filename, ref_dir);
    strcat(ref_filename, selected_book->path + ref_dir_len);
    strcpy(strrchr(ref_filename, '.') + 1, "bib");

    FILE *ref_file = fopen(ref_filename, "wb+");
    if(ref_file == NULL) {
       exit_and_report();
    }
    free(ref_dir);
    free(ref_filename);
    fprintf(ref_file, "@book{book:%s,\n", selected_book->id);
    fprintf(ref_file, "%-16s{%s},\n", "title = ", selected_book->title);
    fprintf(ref_file, "%-16s{%s},\n", "author =", selected_book->authors);
    fprintf(ref_file, "%-16s{%s},\n", "publisher =",
            selected_book->publisher ? selected_book->publisher : "");
    fprintf(ref_file, "%-16s{%s},\n",
            "isbn =", selected_book->isbn ? selected_book->isbn : "");
    fprintf(ref_file, "%-16s{%s},\n", "year =", selected_book->year);
    fprintf(ref_file, "%-16s{%s},\n",
            "series =", selected_book->series ? selected_book->series : "");
    fprintf(ref_file, "%-16s{%s},\n",
            "edition =", selected_book->edition ? selected_book->series : "");
    fprintf(ref_file, "%-16s{%s},\n",
            "volume =", selected_book->volume ? selected_book->volume : "");
    fprintf(ref_file, "%-16s{%s}\n}\n", "url =", selected_book->url);

    fclose(ref_file);
  }
}

void split_url(const char *url, char **hostname, char **path) {
  char tmp_host[255], tmp_path[1024];
  sscanf(url, "http://%[^/]/%s", tmp_host, tmp_path);
  *hostname = (char *)ecalloc(strlen(tmp_host) + 1, sizeof(char));
  *path = (char *)ecalloc(strlen(tmp_path) + 1, sizeof(char));
  strcpy(*hostname, tmp_host);
  strcpy(*path, tmp_path);
}

void print_table_of_books(struct book_t *array, const int array_len,
                          const int curr_page, const int status) {
  enum {
    INDEX,
  };

  struct columns {
    char name[16];
    int max_length;
  };

  const struct columns columns[] = {
      {"Idx", 4},      {"Authors", 16}, {"Title", 30},
      {"Publisher", 10}, {"Year", 6},     {"Pages", 8},
      {"Language", 12},  {"Size", 6},     {"Extension", 12}
  };

  int total_len = 2;
  const int columns_len =  (int)CONST_ARR_LEN(columns);
  for (int i = 0; i < columns_len; i += 1) {
    total_len += columns[i].max_length;
  }
  draw_table_line(total_len);
  if (status == SUCCESS) {

    for (int curr_column = 0; curr_column < columns_len; curr_column += 1) {
      printf_center(columns[curr_column].name, columns[curr_column].max_length);
      putchar('|');
    }
    putchar('\n');

    draw_table_line(total_len);

    for (int curr_book = 0; curr_book < array_len; curr_book += 1) {
      for (int curr_column = 0; curr_column < columns_len; curr_column += 1) {
        switch (curr_column) {
        case INDEX:
          printf_int_center(curr_book + 1, columns[curr_column].max_length);
          break;
        case AUTHORS:
          draw_book_column(array[curr_book].authors, columns[curr_column].max_length);
          break;
        case TITLE:
          draw_book_column(array[curr_book].title, columns[curr_column].max_length);
          break;
        case PUBLISHER:
          draw_book_column(array[curr_book].publisher,
                           columns[curr_column].max_length);
          break;
        case YEAR:
          draw_book_column(array[curr_book].year, columns[curr_column].max_length);
          break;
        case PAGES:
          draw_book_column(array[curr_book].lang, columns[curr_column].max_length);
          break;
        case SIZE:
          draw_book_column(array[curr_book].size, columns[curr_column].max_length);
          break;
        case EXT:
          draw_book_column(array[curr_book].ext, columns[curr_column].max_length);
          break;
        }
      }
      draw_table_line(total_len);
    }
    printf("\nCurrent page: [%d/%d]\n", curr_page + 1, MAX_PAGES);
  } else {
    /* FAILURE */
    printf_center("Not found. Try again.", total_len);
    draw_table_line(total_len);
  }
}

void draw_table_line(const int len) {
   /*
  for (int i = 0; i < len; i += 1) {
    putchar('-');
  }
  */
  putchar('\n');
}

void draw_book_column(char *text, const size_t len) {
  if (strlen(text) > len) {
    char tmp = text[len];
    text[len] = '\0';
    printf_center(text, len);
    text[len] = tmp;
  } else {
    printf_center(text, len);
  }
}

void print_more_info(struct book_t *selected_book) {
  puts("---> Selected book information");
  printf("\t\t%s\n", selected_book->title);
  printf("Authors: %s\n", selected_book->authors);
  printf("Year: %s\n", selected_book->year);
  printf("Pages: %s\n", selected_book->pages);
  printf("Series: %s\n", selected_book->series);
  if (selected_book->edition) {
    printf("Edition: %s\n", selected_book->edition);
  }
  printf("Language: %s\n", selected_book->lang);
  printf("ISBN: %s\n", selected_book->isbn);
  if (selected_book->description) {
    putchar('\n');
    printf("Description: %s\n", selected_book->description);
  }
  puts("--->");
}

int user_input(const char *msg, const char *info, int (*check_input)(char *)) {
  char input[10];
  int choice, i = 0;
  do {
    if (i++) {
      puts(info);
    }
    printf("\n%s\n>>> ", msg);
    scanf("%s", input);
  } while ((choice = check_input(input)) == FAILURE);
  return choice;
}

int user_input_arg(const char *msg, const char *info, char *container) {
  size_t container_len;
  int i = 0;
  printf("\n%s\n>>> ", msg);
  do {
    if (i++) {
      puts(info);
    }
    scanf("%s", container);
    container_len = strlen(container);
    if (container_len == 1 && (*container == 'q' || *container == 'Q' ||
                               *container == 'n' || *container == 'N')) {
      return FAILURE;
    }

  } while (container_len <= 3);
  return SUCCESS;
}

int check_input_search_page(char *in) {
  bool is_page = false;
  int ans = 0;
  /* prevent stupid inputs */
  const long long input_len = strlen(in);
  if (input_len < 0 || input_len > INT_MAX / 4) {
    return false;
  }
  if (*in == 'p' || *in == 'P') {
    is_page = true;
    in += 1;
  }
  if(sscanf(in, "%d", &ans) <= 0 && input_len > 1) {
     return false;
  }
  if(is_page) {
     ans = (ans <= MAX_PAGES) ? (-ans - 1) : FAILURE;
  } else if(*in == 'q' || *in == 'Q' || ans == 0) {
     ans = EXIT_SUCCESS;
  } else {
     ans = (ans <= MAX_BOOKS_IN_CURR_PAGE) ? (ans - 1) : FAILURE;
  }
  return ans;
}

int check_input_book(char* in) {
  return (*in == 'y' || *in == 'Y')
             ? SUCCESS
             : (*in == 'n' || *in == 'N') ? INT_MAX : FAILURE;
}

char *get_dir(const char *dir, long *len) {
  long dir_len = strlen(dir);
  char *new_dir = (char *)ecalloc(dir_len + 2, sizeof(char));
  strcpy(new_dir, dir);
  char *last_slash = strrchr(dir, '/');
  if ((last_slash - dir + 1) != dir_len) {
    new_dir[dir_len] = '/';
    dir_len += 1;
  }
  *len = dir_len;
  return new_dir;
}
