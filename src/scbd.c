#include "scbd.h"

static int MAX_PAGES = INT_MAX;
static int MAX_BOOKS_IN_CURR_PAGE = INT_MAX;

int exec(char *args[]) {
  if (!args[SEARCH_PATTERN])
    usage();
  CLEAR;
  struct pages pages;
  memset(&pages, 0, sizeof(struct pages));
  int selected_book = FAILURE, curr_page = 0;
  char *log_msg = NULL;
  int download_book_page_status = FAILURE;
  /* grep user args if exists */
  char *local_save_dir = !args[BOOK_PATH] ? (char *)save_dir : args[BOOK_PATH];
  char *local_save_ref_dir =
      !args[BOOK_BIB_PATH] ? (char *)save_ref_dir : args[BOOK_BIB_PATH];
  char *local_sort_order =
      !args[SORT_ORDER] ? (char *)sort_book_order : args[SORT_ORDER];
  char *local_sort_mode =
      !args[SORT_MODE] ? (char *)sort_mode : args[SORT_MODE];
  while (download_book_page_status == FAILURE) {
    greeting_message(); /* welcome to scbd etc etc */
    if (download_search_page(
            args[SEARCH_PATTERN], &log_msg, &pages.lib[curr_page].books,
            &pages.lib[curr_page].size, curr_page, &pages.bitset,
            local_sort_order, local_sort_mode) == FAILURE) {
      fprintf(stderr, "%s\n", log_msg + 1);
      free(log_msg);
      break;
    }
    MAX_BOOKS_IN_CURR_PAGE = pages.lib[curr_page].size;
    if ((selected_book = user_input(
             "Select a book [1 - n] or [p|P]age [1 - n] ([q|Q|0] to exit)",
             "Input a number to pick a book or p[NUM] to jump to NUM page",
             check_input_search_page)) == LOCAL_EXIT)
      break;
    else if (selected_book < FAILURE) {
      /* page return a number between [-n, -2], convert it to arr idx */
      curr_page = -(selected_book + 1) - 1;
      continue;
    }
    selected_book -= 1; /* user input is [1 - n], we need to convert it */
    if (!pages.lib[curr_page].books[selected_book].id)
      download_mirror_page(&pages.lib[curr_page].books[selected_book],
                           &log_msg);
    /* first download the book page in gen lib then download the document it
     * self */
    if ((download_book_page_status = download_book_page(
             &pages.lib[curr_page].books[selected_book], &log_msg)) == SUCCESS)
      log_msg = download_book(&pages.lib[curr_page].books[selected_book],
                              local_save_ref_dir, local_save_dir);
    else
      download_book_page_status = FAILURE;
  }
  if (download_book_page_status == SUCCESS)
    success_message(log_msg, &pages.lib[curr_page].books[selected_book],
                    local_save_ref_dir);
  pages_book_t_free(&pages);
  return EXIT_SUCCESS;
}

void logo(void) {
  /* font generated by figlet */
  CLEAR;
  putchar('\n');
  puts("          _         _ \n"
       " ___  ___| |__   __| |\n"
       "/ __|/ __| '_ \\ / _` |\n"
       "\\__ | (__| |_) | (_| |\n"
       "|___/\\___|_.__/ \\__,_|\n");
}

void greeting_message(void) {
  logo();
  puts("\nWelcome to Simple C Book Downloader!\n"
       "We're looking for your book, may take a while.\n");
}

void help_message(void) {
  printf(
      "Simple C Book Downloader\n"
      "Search for books/articles in Library Genesis\n"
      "\nRequired arguments:\n"
      "\t%-16sSet the string search (usually author/book name)\n\n" //-s
      "Optional arguments:\n"
      "\t%-16sShow this help message\n"
      "\t%-16sSet another sort order { id | author | title | publisher | year "
      "| pages | filesize | extension }\n"
      "\t%-16sSet another sort mode { ASC[endant] | DESC[endant] }\n"
      "\t%-16sSet another reference folder (where .bib will be downloaded) "
      "[empty string to ignore bib file]\n"
      "\t%-16sSet another book folder [empty string to ignore book file]\n"
      "\t%-16sVerbose mode\n\n",
      "-s", "-h", "-o", "-m", "-b", "-d", "-v");
}

void success_message(char *msg, const struct book_t *selected_book,
                     const char *local_save_ref_dir) {
  if (*(selected_book->path))
    printf("\n\n\t\t%s\n\nYour book is in %s.\n", msg + 1, selected_book->path);
  if (*local_save_ref_dir)
    printf("The book .bib reference file is in %s dir.\n", local_save_ref_dir);
  puts("Have a nice day!\n");
  free(msg);
}

void check_log_msg(char *msg) {
  if (*msg) {
    char log_msg[LOGMSG_SIZE] = {'\0'};
    strcpy(log_msg, msg);
    free(msg);
    die(log_msg);
  }
  free(msg);
}

int download_search_page(char *pattern, char **log_msg, struct book_t **books,
                         int *books_len, const int curr_page,
                         uint64_t *cached_pages, const char *sort_book_order,
                         const char *sort_mode) {
  printf("\nSearch pattern: %s\n\nWarning: some book information may be wrong "
         "because of mistake in it's upload, after downloading it double check "
         "the reference file.\n",
         pattern);
  if (!is_cached(curr_page, *cached_pages)) {
    int status;
    FILE *rcvd_file = NULL;
    int file_size = 0;
    enum { EXTRA_ARGS_LEN = 64 };

    char extra_args[EXTRA_ARGS_LEN] = {'\0'};
    sprintf(extra_args, "&res=%d&page=%d&sort=%s&sortmode=%s",
            MAX_BOOKS_PER_PAGE, curr_page + 1, sort_book_order, sort_mode);
    char *full_path = (char *)ecalloc(strlen(gen_lib_search_path) +
                                          strlen(pattern) + EXTRA_ARGS_LEN + 1,
                                      sizeof(char));

    /* replace the spaces for '+' to search with http */
    for (int cursor = 0; pattern[cursor]; cursor += 1)
      if (isspace(pattern[cursor]))
        pattern[cursor] = '+';

    sprintf(full_path, "%s%s%s", gen_lib_search_path, pattern, extra_args);
    /* Create a tmpfile for the html page */
    *log_msg = page_downloader(gen_lib, full_path, &rcvd_file, &file_size,
                               TMP_FILE, !PROGRESS_BAR);
    free(full_path);
    if (**log_msg)
      return FAILURE;
    else
      check_log_msg(*log_msg);

    *log_msg = search_page(rcvd_file, file_size, books, books_len, &status,
                           &MAX_PAGES);
    if (!curr_page) {
      MAX_PAGES = MIN(MAX_PAGES, (int)sizeof(uint64_t) * 8);
      *books_len = MIN(*books_len, MAX_BOOKS_PER_PAGE);
    }
    check_log_msg(*log_msg);
    *cached_pages |= (1ULL << curr_page);
  }

  print_table_of_books(*books, *books_len, curr_page);
  print_cached_pages(*cached_pages);
  /* replace the '+' for spaces to show it in terminal */
  for (int cursor = 0; pattern[cursor]; cursor += 1)
    if (pattern[cursor] == '+')
      pattern[cursor] = ' ';
  return SUCCESS;
}

uint64_t is_cached(const int curr_page, const uint64_t cached_pages) {
  return cached_pages & (1ULL << curr_page);
}

void print_cached_pages(const uint64_t bitset) {
  printf("Cached pages (instant loading): ");
  FOR_BITSET(bitset, cursor) {
    if (cursor)
      printf(", ");
    printf("%lu", cursor + 1);
  }
  putchar('\n');
}

void download_mirror_page(struct book_t *selected_book, char **log_msg) {
  FILE *rcvd_file = NULL;
  int file_size = 0;

  *log_msg = page_downloader(gen_lib, selected_book->url, &rcvd_file,
                             &file_size, TMP_FILE, !PROGRESS_BAR);
  check_log_msg(*log_msg);

  *log_msg = mirror_page(rcvd_file, file_size, selected_book);
  check_log_msg(*log_msg);
}

bool download_book_page(struct book_t *selected_book, char **log_msg) {
  FILE *rcvd_file = NULL;
  int file_size = 0;
  char *hostname, *path;
  split_url(selected_book->url, &hostname, &path);
  *log_msg = page_downloader(hostname, path, &rcvd_file, &file_size, TMP_FILE,
                             !PROGRESS_BAR);
  free(hostname);
  free(path);
  check_log_msg(*log_msg);

  *log_msg = book_page(rcvd_file, file_size, selected_book);
  check_log_msg(*log_msg);

  CLEAR;
  print_more_info(selected_book);
  return user_input("Continue?", "[y]es or [n]o", check_input_book);
}

char *download_book(struct book_t *selected_book, char *local_save_ref_dir,
                    char *local_save_dir) {
  FILE *rcvd_file = NULL;
  int file_size = 0;
  long book_filename_len = 0;
  char *hostname = NULL, *path = NULL, *log_msg = NULL;
  const int page_download_status =
      *local_save_dir ? REGULAR_FILE : JUST_FILENAME;
  split_url(selected_book->download_url, &hostname, &path);
  if (page_download_status == REGULAR_FILE) {
    selected_book->path = get_dir(local_save_dir, &book_filename_len);
    int mkdir_status =
        mkdir(selected_book->path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    if (mkdir_status == ENOTDIR || mkdir_status == ENAMETOOLONG)
      die("scbd.c - save_dir variable not configured properly.");
  }
  log_msg = page_downloader(hostname, path, &rcvd_file, &file_size,
                            page_download_status, PROGRESS_BAR,
                            &selected_book->path, book_filename_len);
  free(hostname);
  free(path);
  if (page_download_status == REGULAR_FILE)
    fclose(rcvd_file);
  generate_ref(selected_book, book_filename_len, local_save_ref_dir);
  return log_msg;
}

void generate_ref(const struct book_t *selected_book, const long start_book_fn,
                  char *local_save_ref_dir) {
  if (*local_save_ref_dir) {
    long ref_dir_len;
    char *ref_dir = get_dir(local_save_ref_dir, &ref_dir_len);
    int mkdir_status = mkdir(ref_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    if (mkdir_status == ENOTDIR || mkdir_status == ENAMETOOLONG)
      die("save_ref_dir variable not configured properly.");
    const long book_path_len = strlen(selected_book->path);
    char *ref_filename = ecalloc(
        (book_path_len - start_book_fn + 4) + ref_dir_len, sizeof(char));
    sprintf(ref_filename, "%s%s", ref_dir, selected_book->path + start_book_fn);
    strcpy(strrchr(ref_filename, '.') + 1, "bib");

    FILE *ref_file = efopen(ref_filename, "wb+");
    free(ref_dir);
    free(ref_filename);

    fprintf(ref_file,
            "@book{book:%s,\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s},\n"
            "%-16s{%s}\n}\n",
            selected_book->id, "title =", selected_book->title,
            "author =", selected_book->authors, "publisher =",
            selected_book->publisher ? selected_book->publisher : "",
            "isbn =", selected_book->isbn ? selected_book->isbn : "",
            "year =", selected_book->year,
            "series =", selected_book->series ? selected_book->series : "",
            "edition =", selected_book->edition ? selected_book->edition : "",
            "volume =", selected_book->volume ? selected_book->volume : "",
            "url =", selected_book->url);
    fclose(ref_file);
  } else
    fprintf(
        stderr,
        "\n[WARNING] save_ref_dir variable not set nor -b argument used.\n");
}

void split_url(const char *url, char **hostname, char **path) {
  char tmp_host[255], tmp_path[1024];
  sscanf(url, "http://%[^/]/%s", tmp_host, tmp_path);
  *hostname = (char *)ecalloc(strlen(tmp_host) + 1, sizeof(char));
  *path = (char *)ecalloc(strlen(tmp_path) + 1, sizeof(char));
  strcpy(*hostname, tmp_host);
  strcpy(*path, tmp_path);
}

void print_table_of_books(struct book_t *array, const int array_len,
                          const int curr_page) {
  enum {
    INDEX,
  };

  struct columns {
    char name[16];
    int max_length;
  };

  const struct columns columns[] = {
      {"Idx", 2},        {"Authors", 8}, {"Title", 20},
      {"Publisher", 10}, {"Year", 6},    {"Pages", 6},
      {"Language", 3},   {"Size", 6},    {"Ext", 5}};

  int total_len = 2;
  const int columns_len = (int)CONST_ARR_LEN(columns);
  for (int curr_column = 0; curr_column < columns_len; curr_column += 1)
    total_len += columns[curr_column].max_length;

  /*
   * Table header (trying to figure out how to fix this)
 printf("  ");
 for (int curr_column = 0; curr_column < columns_len; curr_column += 1) {
   printf_center(columns[curr_column].name, columns[curr_column].max_length);
 }
   */
  putchar('\n');
  for (int curr_book = 0; curr_book < array_len; curr_book += 1) {
    for (int curr_column = 0; curr_column < columns_len; curr_column += 1) {
      switch (curr_column) {
      case INDEX:
        printf("  ");
        printf_int_center(curr_book + 1, columns[curr_column].max_length);
        break;
      case BOOK_AUTHORS:
        draw_book_column(array[curr_book].authors,
                         columns[curr_column].max_length);
        break;
      case BOOK_TITLE:
        draw_book_column(array[curr_book].title,
                         columns[curr_column].max_length);
        break;
      case BOOK_PUBLISHER:
        draw_book_column(array[curr_book].publisher,
                         columns[curr_column].max_length);
        break;
      case BOOK_YEAR:
        draw_book_column(array[curr_book].year,
                         columns[curr_column].max_length);
        break;
      case BOOK_PAGES:
        draw_book_column(array[curr_book].pages,
                         columns[curr_column].max_length);
        break;
      case BOOK_LANG:
        draw_book_column(array[curr_book].lang,
                         columns[curr_column].max_length);
        break;
      case BOOK_SIZE:
        draw_book_column(array[curr_book].size,
                         columns[curr_column].max_length);
        break;
      case BOOK_EXT:
        draw_book_column(array[curr_book].ext, columns[curr_column].max_length);
        break;
      }
    }
    putchar('\n');
  }
  printf("\nCurrent page: [%d/%d]\n", curr_page + 1, MAX_PAGES);
}

void draw_book_column(char *text, const size_t len) {
  if (strlen(text) > len) {
    char tmp = text[len];
    text[len] = '\0';
    printf_center(text, len);
    text[len] = tmp;
  } else {
    printf_center(text, len);
  }
}

void print_more_info(struct book_t *selected_book) {
  logo();
  printf("---> BOOK INFO\n\n"
         "%-15s%s\n"
         "%-15s%s\n"
         "%-15s%s\n"
         "%-15s%s\n"
         "%-15s%s\n",
         "Title:", selected_book->title, "Authors:", selected_book->authors,
         "Year:", selected_book->year, "Pages:", selected_book->pages,
         "Series:", selected_book->series);

  if (selected_book->periodical)
    printf("%-15s%s\n", "Periodical:", selected_book->periodical);
  if (selected_book->edition)
    printf("%-15s%s\n", "Edition:", selected_book->edition);

  printf("%-15s%s\n"
         "%-15s%s\n"
         "%-15s%s\n",
         "Language:", selected_book->lang, "ISBN:", selected_book->isbn,
         "Filesize:", selected_book->size);

  if (selected_book->description)
    printf("\n%-15s%s\n", "Description:", selected_book->description);
  puts("\n--->");
}

int user_input(const char *msg, const char *info, int (*check_input)(char *)) {
  char input[10];
  int choice, error = 0;
  do {
    if (error++)
      puts(info);
    printf("\n%s\n>>> ", msg);
    scanf("%s", input);
  } while ((choice = check_input(input)) == FAILURE);
  return choice;
}

int user_input_arg(const char *msg, const char *info, char *container) {
  size_t container_len;
  int error = 0;
  printf("\n%s\n>>> ", msg);
  do {
    if (error++)
      puts(info);
    scanf("%s", container);
    container_len = strlen(container);
    if (container_len == 1 && (*container == 'q' || *container == 'Q' ||
                               *container == 'n' || *container == 'N'))
      return FAILURE;

  } while (container_len <= 3);
  return SUCCESS;
}

int check_input_search_page(char *in) {
  bool is_page = false;
  int ans = 0;
  /* prevent stupid inputs */
  const long long input_len = strlen(in);
  if (input_len < 0 || input_len > INT_MAX / 4)
    return FAILURE;
  if (*in == 'p' || *in == 'P') {
    is_page = true;
    in += 1;
  }
  if (sscanf(in, "%d", &ans) <= 0 && input_len > 1)
    return FAILURE;
  if (is_page)
    ans = (ans <= MAX_PAGES) ? (-ans - 1) : FAILURE;
  else if (!ans)
    ans = LOCAL_EXIT;
  else if (ans > MAX_BOOKS_IN_CURR_PAGE)
    ans = FAILURE;
  return ans;
}

int check_input_book(char *in) {
  return (*in == 'y' || *in == 'Y' || *in == '1')
             ? SUCCESS
             : (*in == 'n' || *in == 'N' || *in == '0') ? LOCAL_EXIT : FAILURE;
}

char *get_dir(char *dir, long *len) {
  long dir_len = strlen(dir);
  char *new_dir = NULL;
  char *home_dir = NULL;
  if (*dir == '~') {
    home_dir = getenv(HOMEPATH);
    dir_len += strlen(home_dir) - 1;
    dir += 1;
  }
  new_dir = (char *)ecalloc(dir_len + 3, sizeof(char));
  if (home_dir) {
    strcpy(new_dir, home_dir);
  }
  strcat(new_dir, dir);
  char *last_slash = strrchr(dir, '/');
  if (!last_slash || (last_slash - dir + 1) != dir_len) {
    new_dir[dir_len] = '/';
    dir_len += 1;
  }
  *len = dir_len;
  return new_dir;
}

